### **SynchronizationContext** — это механизм, который определяет, в каком потоке будет выполнено продолжение после await.

Как работает по умолчанию:
```csharp
async void ButtonClick()
{
    // Мы в UI-потоке
    var data = await GetDataAsync(); 
    // По умолчанию: продолжение пытается выполниться в UI-потоке
    textBox.Text = data; // Успешно!
}
```
Когда UI-поток занят:
```csharp
void BadMethod()
{
    // Вызываем асинхронный метод и ждем его завершения
    var task = GetDataAsync();
    task.Wait(); // Блокируем UI-поток
    
    // Но GetDataAsync внутри имеет await, который хочет вернуться в UI-поток
    // UI-поток заблокирован → не может принять продолжение → ДЕДЛОК
}
```

**Что делает ConfigureAwait(false):**
```csharp
public async Task<string> GetDataAsync()
{
    var data = await DownloadDataAsync().ConfigureAwait(false);
    // Теперь продолжение выполнится в ЛЮБОМ доступном потоке из пула
    // без попытки вернуться в исходный контекст
    return ProcessData(data);
}
```

### Почему всегда использовать ConfigureAwait(false) в библиотеках?
1. Избегание дедлоков. Библиотека не знает, в каком контексте её будут использовать. Может быть UI, может быть ASP.NET, может быть консольное приложение.
2. Повышение производительности. Восстановление контекста — это дополнительные накладные расходы.
3. Предсказуемость поведения. Библиотека должна вести себя одинаково независимо от окружения.